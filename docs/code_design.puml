@startuml

<style>
title {
  FontSize 24
}
</style>
title Basic Screens layout

abstract class Game {
    LibGDX class.
}

class Main extends Game {
    -- Overrides --
    void create()
    void render()
    void dispose()
    -- Screens --
    MainMenuScreen
    GameplayScreen
    -- Fields --
    Renderer renderer;
    RenderingSystem renderingSystem;
}

class MainMenuScreen implements Screen
Main::mainMenuScreen --> MainMenuScreen: First screen
MainMenuScreen -> GameplayScreen: Switches screen
MainMenuScreen <- GameplayScreen: Switches screen back

class GameplayScreen implements Screen {
    -- Overrides --
    void show()
    void hide()
    void render()
    void resize()
    void pause()
    void resume()
    void dispose()
    --
    constructor()
    void input()
    void logic()
    void draw()
    -- Fields --
    final Main main
    GlobalGameState
    ConcurrentLinkedQueue<Entity> entities;
    SystemsManager
}

newpage

<style>
title {
  FontSize 24
}
</style>
title Rendering Utilities

class Renderer {
    SpriteBatch batch;
}
Renderer -[hidden]- StateMachine
class StateMachine<State extends Enum<State>> {
    State state;
    HashMap<State, StateNode> states;

    State getState()
    void advanceState()
    void setNextStateFrom(State from, State to)
    void setNextTmpStateFrom(State from, State to)
}
StateMachine::states --> StateNode
class StateNode <State> {
    StateNode<State> next;
    StateNode<State> tmpNext;
}

package Sprites {
    class Sprite {
        TextureRegion textureRegion;
    }
    class AnimatedSprite {
        Animation<TextureRegion> animation;
        Vector2 offsetPosition;
        Vector2 baseDimensions;

        constructor(animation, offsetPosition, baseDimensions)
        static AnimatedSprite empty()
        void render(Renderer renderer, Vector2 position, float animationTimer)
        float getAnimationDuration()
    }
    AnimatedSprite <-- AnimatedStateSprite::animations
    class AnimatedStateSprite<State extends Enum<State>> {
        Map<State, AnimatedSprite> animations;
        void render(Renderer renderer, Vector2 position, State state, float animationTimer)
    }
    AnimatedStateSprite <-- AnimatedStateMachineSpriteInstance::animatedStateSprite
    class AnimatedStateMachineSpriteInstance<State extends Enum<State>> {
        AnimatedStateSprite<State> animatedStateSprite;
        StateMachine<State> stateMachine;
        State prevState;
        float stateElapsedTime;

        constructor(AnimatedStateSprite<State>, StateMachine)
        void render(Renderer renderer, Vector2 position, float deltaTime)
    }
    StateMachine <-- AnimatedStateMachineSpriteInstance::stateMachine
    note right of AnimatedStateMachineSpriteInstance::render
        Is responsible for **advancing state machine**,
        so that animations dictate the
        states' change the timing.
    end note
}

newpage

<style>
title {
  FontSize 24
}
</style>
title General Entity Component System

together {
    class Entity::Builder {
        constructor(EntityType type)
        Builder add(componentType, component)
        Entity build()
    }
    class Entity {
        E.g. Frog, Hedgehog, Bullets, Fireballs etc.
        -- Components --
        ConcurrentHashMap<Class, Component> components;
        -- Fields --
        final EntityType type;
    }
}
Entity -> EntityType
enum EntityType {
    FROG,
    BULLET,
    HEDGEHOG,
    OTHER
}

newpage

interface RenderableComponent extends Component {
    virtual void render(Renderer, deltaTime, currentTimestamp)
}
note right of RenderableComponent
    Rendering is handled in rendering
    system with high frequency.
end note
note left of RenderableComponent::render
    Animations depend on deltaTime
    calculate the right frame.
    Positions depend on currentTimestamp.
end note

newpage

interface TransformComponent extends Component {
    position;
    speed;
    getSpeed()
    getAdvancedPosition(currentTimestamp)
    setPosition(position, currentTimestamp)
}
note left of TransformComponent::speed
    Frogs have speed of 0.
end note
note left of TransformComponent::getAdvancedPosition
    Uses speed and currentTimestamp to calculate
    new position. It is useful to predict new
    position in the rendering system for smooth movement.
end note
interface StateComponent extends Component
class HealthComponent extends Component {
    health;
}

newpage

interface Component
interface ColliderComponent extends Component {
    ConvexShape getConvexShape(Vector2 origin)
}
interface CollisionActionComponent extends Component {
    void collide(deltaTime, Entity other)
}
interface BehaviourComponent extends Component {
    virtual void tick(deltaTime, Entity)
}

newpage

<style>
title {
  FontSize 24
}
</style>
title Frog Entities (other entity types are similar)

interface Component {
}
interface CollisionActionComponent extends Component {
}

class KnightFrogCollisionActionComponent implements CollisionActionComponent {
}
class BardFrogCollisionActionComponent implements CollisionActionComponent {
}
KnightFrogCollisionActionComponent -[hidden]- WizardFrogCollisionActionComponent
class WizardFrogCollisionActionComponent implements CollisionActionComponent {
}
class TankyFrogCollisionActionComponent implements CollisionActionComponent {
}
BardFrogCollisionActionComponent -[hidden]- TankyFrogCollisionActionComponent

interface StateComponent extends Component
class FrogStateComponent implements StateComponent {
    final StateMachine<FrogState> generalStateMachine;
    volatile boolean isAttacked;

    boolean getIsAttacked()
    boolean setIsAttacked(boolean newIsAttacked)
    StateMachine<FrogState> getGeneralStateMachine()
    FrogState getGeneralState()
    void setNextGeneralState(FrogState nextState)
    void advanceState()
}
note left of FrogStateComponent::setNextGeneralState
    Adds a temporary edge to the StateMachine.
end note
enum FrogState {
    IDLE,
    ACTION,
    DYING,
    NONEXISTENT
}
FrogStateComponent::generalState --> FrogState

interface RenderableComponent extends Component {
}
class FrogRenderableComponent implements RenderableComponent {
    Queries state machine
    to decide which
    animation to render.
    --
    final TransformComponent transformComponent;
    final FrogStateComponent fullStateComponent;
    final AnimatedStateMachineSpriteInstance<FrogState> spriteInstance;
    --
    constructor(TransformComponent, FrogStateComponent, AnimatedStateSprite<FrogState>)
}
FrogRenderableComponent --> FrogStateComponent

class FrogFactory << Singleton >> {
    Creates Frog Entity, necessary Components
    and manages their resources (e.g. textures).
    --
    Entity createKnightFrog()
    Entity createBardFrog()
    Entity createWizardFrog()
    Entity createTankyFrog()
}

newpage

<style>
title {
  FontSize 24
}
</style>
title Systems Management

interface System {
    void tick(deltaTime, ConcurrentLinkedQueue<Entity> entities;
}
class CollisionSystem implements System
class PhysicsSystem implements System
class GlobalIncomeSystem implements System
class HealthSystem implements System
class ThrottledSystem implements System {
    constructor(tickRate, System)
}

class SystemsManager {
    Schedules systems unrelated to rendering.
    Rendering has to run in the main thread,
    which is OpenGL limitation.
    --
    final List<System> systems;
    final tickRate;
    final ExecutorService executor;
    final ConcurrentLinkedQueue<Entity> entities;
    --
    volatile boolean running;
    volatile boolean paused;
    --
    constructor(tickRate, systems, entities)
    --
    void start()
    void stop()
    void pause()
    void resume()
    void tick(deltaTime)
}

class SystemsManager::Builder {
    constructor()
    Builder addSystem(System)
    Builder addThrottledSystem(tickRate, System)
    Builder tickRate(tickRate)
    SystemsManager build(entities)
}

@enduml
